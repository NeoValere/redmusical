
import { NextResponse } from 'next/server';
import { createServerClient } from '@supabase/ssr';
import { cookies } from 'next/headers';
import prisma from '@/lib/prisma';
import { Prisma } from '@prisma/client'; // Import Prisma types

export async function GET(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  // As per Next.js 15 guidelines, dynamic APIs like params and cookies are asynchronous.
  // See: https://nextjs.org/docs/messages/sync-dynamic-apis

  const { id: musicianId } = await params; // Await params resolution
  console.log({ musicianIdFromParams: musicianId })
  try {
    const cookieStore = await cookies(); // Await cookies directly
    const supabase = createServerClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
      {
        cookies: {
          getAll: () => cookieStore.getAll(),
        },
      }
    );
    const { data: { user } } = await supabase.auth.getUser();
    // isOwner check might need adjustment if we are fetching by musicianId and not userId directly
    // For now, let's assume musicianId is the primary key of the Musician table.
    // If user.id is needed for ownership check, it should be compared against musicianData.userId later.
    

    // Define the type for the included relations, explicitly listing fields as they come from Prisma (now camelCase)
    type MusicianWithRelations = {
      id: string;
      userId: string;
      fullName: string | null;
      artisticName: string | null; // Added artisticName
      bio: string | null;
      profileImageUrl: string | null;
      city: string | null;
      province: string | null;
      websiteUrl: string | null;
      experienceLevel: string | null;
      hourlyRate: number | null;
      isPublic: boolean | null;
      acceptsCollaborations: boolean | null;
      acceptsGigs: boolean | null;
      socialMediaLinks: Prisma.JsonValue | null;
      audioTracks: Prisma.JsonValue | null; // Added audioTracks
      profileColorCover: string | null;
      profileColorCardBackground: string | null;
      profileColorText: string | null;
      profileColorSectionBackground: string | null;
      musicianOrBand: string | null; // Added to differentiate between solo musician or band
      isAutogenerated: boolean | null;
      createdAt: Date; // Expecting Date object from Prisma
      updatedAt: Date | null; // Expecting Date object from Prisma, can be null
      genres: { genre: { id: string; name: string; }; }[];
      instruments: { instrument: { id: string; name: string; }; }[];
      skills: { skill: { id: string; name: string; }; }[];
      availability: { availability: { id: string; name: string; }; }[];
      preferences: { preference: { id: string; name: string; }; }[];
    };


    // Fetch Musician data using Prisma, querying by musicianId (primary key)
    const musicianData = await prisma.musician.findUnique({
      where: { userId: musicianId }, // Query by musicianId (primary key)
      include: {
        genres: {
          select: {
            genre: {
              select: {
                id: true,
                name: true,
              },
            },
          },
        },
        instruments: {
          select: {
            instrument: {
              select: {
                id: true,
                name: true,
              },
            },
          },
        },
        skills: {
          select: {
            skill: {
              select: {
                id: true,
                name: true,
              },
            },
          },
        },
        availability: {
          select: {
            availability: {
              select: {
                id: true,
                name: true,
              },
            },
          },
        },
        preferences: {
          select: {
            preference: {
              select: {
                id: true,
                name: true,
              },
            },
          },
        },
      },
    }) as MusicianWithRelations | null; // Explicitly cast the result

    if (!musicianData) {
      return NextResponse.json({ error: 'Este perfil ya no existe' }, { status: 404 });
    }
    
    // Now that we have musicianData, we can check ownership using musicianData.userId
    const isOwner = user && user.id === musicianData.userId;

    // Check if the profile is private AND the requesting user is NOT the owner
    if (musicianData.isPublic === false && !isOwner) {
      return NextResponse.json({ error: 'Este perfil es privado y no puede ser accedido.' }, { status: 403 });
    }

    // Reconstruct the profile object to match the frontend's expected camelCase type
    // Prisma now returns camelCase fields directly after schema update
    const profile = {
      ...musicianData,
      artisticName: musicianData.artisticName, // Added artisticName
      email: undefined,
      phoneNumber: undefined,
      profileColorCover: musicianData.profileColorCover,
      profileColorCardBackground: musicianData.profileColorCardBackground,
      profileColorText: musicianData.profileColorText,
      profileColorSectionBackground: musicianData.profileColorSectionBackground,
      isAutogenerated: musicianData.isAutogenerated,
      socialMediaLinks: musicianData.socialMediaLinks as Record<string, string> | null,
      audioTracks: musicianData.audioTracks as { title: string; url: string; }[] | null,
      createdAt: musicianData.createdAt?.toISOString() || null,
      updatedAt: musicianData.updatedAt?.toISOString() || null,
      genres: musicianData.genres.map((mg) => mg.genre) ,
      instruments: musicianData.instruments.map((mi) => mi.instrument) ,
      skills: musicianData.skills.map((ms) => ms.skill) ,
      availability: musicianData.availability.map((ma) => ma.availability) ,
      preferences: musicianData.preferences.map((mp) => mp.preference) ,
    };

    return NextResponse.json(profile);
  } catch (error: unknown) {
    console.error('Unexpected error in get-profile API (Prisma):', error);
    if (error instanceof Error) {
      return NextResponse.json({ error: error.message || 'Internal server error' }, { status: 500 });
    }
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}
