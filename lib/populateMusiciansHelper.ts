import { PrismaClient, Prisma } from '@prisma/client';
import { createClient } from '@supabase/supabase-js';
import OpenAI from 'openai';
import { v4 as uuidv4 } from 'uuid';
// import fetch from 'node-fetch'; // Using node-fetch as it's already a dependency

const prisma = new PrismaClient();

// Initialize Supabase client with service role
const supabaseAdmin = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

// Initialize OpenAI client
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

// Helper function to get a random subset of an array
function getRandomSubset<T>(arr: T[], min: number, max: number): T[] {
  const count = Math.floor(Math.random() * (max - min + 1)) + min;
  const shuffled = [...arr].sort(() => 0.5 - Math.random());
  return shuffled.slice(0, count);
}

// Helper function to calculate profile completeness
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function calculateProfileCompleteness(musicianData: any): number {
  const fieldsToConsider = [
    'fullName', 'email', 'city', 'province', 'bio', 'phoneNumber', // email is now generated by AI
    'profileImageUrl', 'artisticName', 'experienceLevel',
    'servicesOffered', 'influences', 'gearHighlights', 'preferredVenueTypes',
    'lookingFor', 'genres', 'instruments', 'skills', 'availability', 'preferences'
    // Add or remove fields as per your definition of a "complete" profile
  ];
  let filledFields = 0;
  fieldsToConsider.forEach(field => {
    const value = musicianData[field];
    if (value !== null && value !== undefined) {
      if (Array.isArray(value) && value.length > 0) {
        filledFields++;
      } else if (typeof value === 'string' && value.trim() !== '') {
        filledFields++;
      } else if (typeof value === 'object' && Object.keys(value).length > 0 && !Array.isArray(value)) { // For connected relations
        filledFields++;
      } else if (typeof value !== 'string' && !Array.isArray(value)) { // For non-string, non-array types like numbers or booleans if they were relevant
        filledFields++;
      }
    }
  });
  return Math.round((filledFields / fieldsToConsider.length) * 100);
}


// eslint-disable-next-line @typescript-eslint/no-explicit-any
export async function populateFakeMusicians(count: number): Promise<{ success: boolean; message: string; createdCount?: number; errors?: any[] }> {
  let createdCount = 0;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const errors: any[] = [];

  // Define personality traits and bio length options
  const PERSONALITY_TRAITS = [
    "Bohemio/a", "Laburante", "Chamuyero/a", "Melancólico/a", "Fiestero/a",
    "Intelectual", "Humilde", "Frontal", "Creativo/a", "Disciplinado/a",
    "Soñador/a", "Práctico/a", "Introvertido/a", "Extrovertido/a", "Puntilloso/a",
    "Relajado/a", "Energético/a", "Sarcástico/a", "Ansioso/a", "Optimista",
    "Distraído/a", "Procrastinador/a", "Directo/a (a veces demasiado)", "Noctámbulo/a",
    "Desordenado/a", "Intenso/a", "Cínico/a con humor", "Pragmático/a", "Impulsivo/a", "Reservado/a"
  ];

  const BIO_LENGTH_OPTIONS = [
    { type: "muy corta", words: [15, 30], description: "una biografía muy corta (entre 15 y 30 palabras)" },
    { type: "corta-mediana", words: [40, 65], description: "una biografía corta-mediana (entre 40 y 65 palabras)" },
    { type: "mediana-larga", words: [75, 110], description: "una biografía mediana-larga (entre 75 y 110 palabras)" }
  ];

  try {
    // Fetch prerequisite data for relations
    const genres = await prisma.genre.findMany({ select: { id: true, name: true } });
    const instruments = await prisma.instrument.findMany({ select: { id: true, name: true } });
    const skills = await prisma.skill.findMany({ select: { id: true, name: true } });
    const availabilities = await prisma.availability.findMany({ select: { id: true, name: true } });
    const preferences = await prisma.preference.findMany({ select: { id: true, name: true } });

    if (!genres.length || !instruments.length || !skills.length || !availabilities.length || !preferences.length) {
      return { success: false, message: "Error: Prerequisite data (genres, instruments, skills, etc.) not found in the database. Please seed them first." };
    }

    const experienceLevels = ["Principiante", "Intermedio", "Avanzado", "Profesional"];

    for (let i = 0; i < count; i++) {
      console.log(`Generating musician ${i + 1} of ${count}...`);
      try {
        // 1. Fetch Base User Data from randomuser.me (Spanish names)
        const randomUserResponse = await fetch('https://randomuser.me/api/?nat=ES');
        if (!randomUserResponse.ok) {
          throw new Error(`Failed to fetch from randomuser.me: ${randomUserResponse.statusText}`);
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const randomUserData = await randomUserResponse.json() as any;
        const user = randomUserData.results[0];

        const baseUserData = {
          gender: user.gender,
          firstName: user.name.first,
          lastName: user.name.last,
          email: user.email,
          phone: user.phone,
          pictureUrl: user.picture.large,
          userId: user.login.uuid, // Use this as the unique userId for the musician
        };

        // 2. Download and Upload Profile Image to Supabase
        let profileImageUrl = null;
        if (baseUserData.pictureUrl) {
          const imageResponse = await fetch(baseUserData.pictureUrl);
          if (!imageResponse.ok) throw new Error('Failed to download image from randomuser.me');
          const imageBuffer = await imageResponse.arrayBuffer();
          const fileExt = baseUserData.pictureUrl.split('.').pop();
          const fileName = `${uuidv4()}.${fileExt}`;
          
          const { error: uploadError } = await supabaseAdmin.storage
            .from('profile-images')
            .upload(fileName, imageBuffer, {
              contentType: `image/${fileExt}`,
              cacheControl: '3600',
              upsert: false,
            });

          if (uploadError) throw uploadError;
          
          const { data: publicUrlData } = supabaseAdmin.storage
            .from('profile-images')
            .getPublicUrl(fileName);
          profileImageUrl = publicUrlData.publicUrl;
        }

        // 3. Prepare Data for OpenAI Prompt
        const selectedGenres = getRandomSubset(genres, 1, 3);
        const selectedInstruments = getRandomSubset(instruments, 1, 2);
        const selectedSkills = getRandomSubset(skills, 2, 5);
        const selectedAvailability = availabilities[Math.floor(Math.random() * availabilities.length)];
        const selectedPreferences = preferences[Math.floor(Math.random() * preferences.length)];
        const selectedTraits = getRandomSubset(PERSONALITY_TRAITS, 3, 3);
        const selectedBioLengthOption = BIO_LENGTH_OPTIONS[Math.floor(Math.random() * BIO_LENGTH_OPTIONS.length)];

        const openAIPromptData = {
          suggestedName: `${baseUserData.firstName} ${baseUserData.lastName}`,
          gender: baseUserData.gender,
          basePhone: baseUserData.phone,
          genres: selectedGenres.map(g => g.name),
          instruments: selectedInstruments.map(inst => inst.name),
          skills: selectedSkills.map(s => s.name),
          personalityTraits: selectedTraits,
          requestedBio: selectedBioLengthOption,
        };

        // 4. Generate Profile Details with OpenAI
        const prompt = `
          You are an expert creative assistant tasked with generating a highly realistic and engaging profile for a musician based in Argentina.
          The goal is to create a profile that feels like a real, imperfect, and sometimes opinionated human being from Argentina. Avoid making them sound universally positive, "ñoño" (nerdy/too perfect), or like a marketing blurb. Their personality traits should guide their strengths, quirks, and even potentially "difficult" or controversial aspects of how they present themselves.
          Some personas, IF THEIR RANDOMLY ASSIGNED TRAITS (like 'Frontal (a veces demasiado)', 'Cínico/a con humor', 'Intenso/a', 'Impulsivo/a') STRONGLY SUGGEST IT, might express strong, unfiltered, or even "politically incorrect" opinions or make provocative statements in their bio or other text fields, reflecting how some real people behave. This could include brief, character-appropriate commentary on social or political topics relevant to Argentina (e.g., "Si votaste a X sos un vendepatria" or "No me banco a los Y"). This should feel like an authentic, albeit potentially abrasive, character choice, not an endorsement. Not all profiles should be like this; it's a possibility for some, to add realism and diversity. The majority should still be within a normal range of human expression.
          All text output, including names, locations, and biographical details, must be in natural, colloquial Argentinian Spanish and sound completely authentic, as if written by a local.
          The tone should be genuine and relatable. Avoid excessive or forced slang, aiming for a style that a real person would use.
          Do not use opening exclamation marks (¡) or opening question marks (¿).

          General Writing Style Guidance (influenced by **${openAIPromptData.personalityTraits.join(', ')}**):
          - The overall writing style (word choice, sentence structure, use of slang/abbreviations, emojis, or even occasional typos) should naturally reflect the assigned personality traits.
          - For example, a 'Relajado/a' or 'Distraído/a' persona might use more casual language, abbreviations (e.g., 'q', 'xq'), or a minor typo. An 'Alegre' or 'Fiestero/a' persona might naturally include an emoji. A 'Puntilloso/a' persona would likely use perfect grammar and formal language.
          - These stylistic elements should emerge organically from the persona. Do NOT explicitly state "I use slang" or "I make typos." Let the style speak for itself.
          - Ensure the entire profile is internally consistent and authentically represents an Argentinian musician. The overall profile should feel unique and not like a template.

          Detailed Instructions for Bio Generation:
          The "bio" should be written in the first person, as if the musician is speaking.
          **IMPORTANT: Do NOT always start the bio by stating the musician's name or that they are a musician.** The \`fullName\` and \`artisticName\` are separate fields. The bio is a chance for their personality to come through immediately. They could start with an anecdote, a question, a bold statement, a complaint (if their personality fits), a philosophical musing, or anything that feels like a natural way for *that specific character* to introduce themselves or their thoughts. Encourage varied openings and avoid a predictable 'introduction -> experience -> conclusion' structure. Bios can be more fragmented, anecdotal, or focus on a single interesting aspect.
          Their way of expressing themself, the stories they choose to tell (or not tell), the details they include or omit, the sentence structure, and the overall tone of the bio should be a natural consequence of them having these underlying personality traits: **${openAIPromptData.personalityTraits.join(', ')}**. Adhere to the requested length: **${openAIPromptData.requestedBio.description}**.
          **Crucially, the musician should NOT explicitly state their personality traits (e.g., 'I am pragmatic'). Instead, let those traits be evident *only* through their words and the way they present their musical journey and self.**
          If the persona's traits strongly lean towards being opinionated or provocative (as per general instructions about character voice), the bio might contain a strong, unfiltered statement or a controversial opinion.
          They *may* choose to mention their connection to the city (that you will generate for the 'city' field), their passion for genres like ${openAIPromptData.genres.join(', ')}, or their skills with instruments like ${openAIPromptData.instruments.join(', ')}, but only if it feels natural and relevant to the persona and story they are implicitly telling. Do not force these details if they don't fit. They might also casually mention their artistic name if it flows naturally, but this is not a requirement.
          The bio should sound like a real Argentinian musician wrote it – genuine, perhaps informal, unique, and sometimes even a bit raw or unfiltered if the personality dictates. The 'correctness' of the grammar and sentence structure should also vary with the persona. Remember, no opening exclamation (¡) or question (¿) marks.

          Based on the following input data:
          ${JSON.stringify(openAIPromptData, null, 2)}

          Generate a JSON object with the following structure and content, ensuring all text is in Argentinian Spanish. The descriptions for each field provide detailed instructions on how the content should be shaped by the input data, especially the personality traits (refer to general instructions above for bio specifics):
          {
            "fullName": "Generate a common and authentic Argentinian full name that is **strongly consistent with the provided gender ('${String(openAIPromptData.gender)}')**. If the 'suggestedName' ('${String(openAIPromptData.suggestedName)}') does not fit the gender or sounds too foreign, prioritize gender consistency and invent a suitable Argentinian name.",
            "artisticName": "A catchy and plausible artistic name in Spanish. This name should subtly hint at their personality traits: **${openAIPromptData.personalityTraits.join(', ')}** and musical genres.",
            "city": "A real city in Argentina that makes sense for a musician with these characteristics.",
            "province": "The Argentinian province corresponding to the chosen city.",
            "bio": "A creatively written bio, following all the detailed instructions provided above for bio generation. It must reflect the persona and adhere to the specified length.",
            "email": "Generate a plausible, common fake email address for this musician (e.g., using common providers like gmail.com, hotmail.com, or a creative personal domain like nombreartistico@musicarg.com). Base the username part on the generated fullName or artisticName. Avoid using 'example.com'.",
            "phoneNumber": "Adapt the provided phone number '${openAIPromptData.basePhone}' to a plausible Argentinian format (e.g., +54 9 XXXX-XXXX), or generate a new fake one if necessary.",
            "experienceLevel": "(Choose one from [${experienceLevels.join(', ')}] that aligns with the bio's tone and the implicitly expressed personality).",
            "servicesOffered": ["Generate a diverse array of 2-4 strings for servicesOffered. The *choices made* for these services should be a consequence of the musician's personality traits: **${openAIPromptData.personalityTraits.join(', ')}**, as well as their genres, instruments, and skills. Avoid generic lists. For example, an 'Impulsivo/a' 'Fiestero/a' might list 'Shows sorpresa en cualquier lado!' as a service. Ensure variety and avoid repetition with other generated profiles."],
            "influences": ["Generate a diverse array of 3-5 strings for influences. These should be specific artists/bands (Argentinian or international popular in Argentina) that align with the musician's genres and the *vibe* suggested by their personality traits. Avoid generic lists."],
            "gearHighlights": ["Generate a diverse array of 2-3 strings for gearHighlights. These should be specific and believable pieces of gear that fit the musician's instruments, genres, and the *type of person* they seem to be based on their traits (e.g., a 'Puntilloso/a' musician might mention a specific vintage pedal; a 'Desordenado/a' one might mention 'un montón de cables y cosas que funcionan... a veces')."],
            "preferredVenueTypes": ["Generate a diverse array of 1-3 strings for preferredVenueTypes. The *choice of venues* should reflect their style, experience, and personality traits. For example, an 'Introvertido/a' musician might prefer 'Pequeños cafés literarios' or 'Sesiones de grabación en estudio', while a 'Fiestero/a' might list 'Festivales al aire libre' and 'Boliches con onda'. It can be an empty array if their traits suggest they are very selective, not actively looking, or perhaps 'Procrastinador/a' and haven't thought about it."],
            "lookingFor": ["Generate a diverse array of 1-3 strings for lookingFor. This should reflect their ambitions and personality traits. For example, a 'Soñador/a' 'Introvertido/a' might be 'Buscando colaborador/a para proyecto experimental online', while an 'Extrovertido/a' 'Laburante' might be 'Conseguir más fechas en bares y eventos'. It can be an empty array if their traits suggest they are self-sufficient, not actively seeking, or perhaps 'Vago/a' and not currently motivated to look."],
            "acceptsCollaborations": "(boolean, true or false, strongly influenced by personality traits like 'Introvertido/a', 'Extrovertido/a', 'Práctico/a', 'Vago/a')",
            "acceptsGigs": "(boolean, true or false, strongly influenced by traits like 'Laburante', 'Fiestero/a', 'Procrastinador/a', 'Ansioso/a')"
          }
        `;
        
        const aiResponse = await openai.chat.completions.create({
          model: 'gpt-4o',
          messages: [{ role: 'user', content: prompt }],
          response_format: { type: "json_object" },
        });

        if (!aiResponse.choices[0].message.content) {
            throw new Error('OpenAI did not return content.');
        }
        
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const generatedData = JSON.parse(aiResponse.choices[0].message.content);

        // 5. Assemble and Create Musician Record in Prisma
        const musicianToCreate: Prisma.MusicianCreateInput = {
          userId: baseUserData.userId,
          fullName: generatedData.fullName,
          email: generatedData.email, 
          city: generatedData.city,
          province: generatedData.province,
          bio: generatedData.bio,
          phoneNumber: generatedData.phoneNumber,
          profileImageUrl: profileImageUrl,
          artisticName: generatedData.artisticName,
          experienceLevel: generatedData.experienceLevel,
          servicesOffered: generatedData.servicesOffered || [],
          influences: generatedData.influences || [],
          gearHighlights: generatedData.gearHighlights || [],
          preferredVenueTypes: generatedData.preferredVenueTypes || [],
          lookingFor: generatedData.lookingFor || [],
          isPublic: true, 
          acceptsCollaborations: typeof generatedData.acceptsCollaborations === 'boolean' ? generatedData.acceptsCollaborations : Math.random() < 0.5,
          acceptsGigs: typeof generatedData.acceptsGigs === 'boolean' ? generatedData.acceptsGigs : Math.random() < 0.5,
          genres: {
            create: selectedGenres.map(g => ({ genre: { connect: { id: g.id } } })),
          },
          instruments: {
            create: selectedInstruments.map(i => ({ instrument: { connect: { id: i.id } } })),
          },
          skills: {
            create: selectedSkills.map(s => ({ skill: { connect: { id: s.id } } })),
          },
          availability: { 
            create: [{ availability: { connect: { id: selectedAvailability.id } } }],
          },
          preferences: { 
            create: [{ preference: { connect: { id: selectedPreferences.id } } }],
          },
        };
        
        musicianToCreate.profileCompleteness = calculateProfileCompleteness(musicianToCreate);

        await prisma.musician.create({ data: musicianToCreate });
        createdCount++;
        console.log(`Successfully created musician: ${generatedData.fullName}`);

      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      } catch (error: any) {
        console.error(`Error creating musician ${i + 1}:`, error.message);
        errors.push({ musicianIndex: i + 1, error: error.message, stack: error.stack });
      }
    }

    if (createdCount > 0) {
      return { success: true, message: `Successfully created ${createdCount} of ${count} musicians.`, createdCount, errors };
    } else {
      return { success: false, message: `Failed to create any musicians after ${count} attempts.`, errors };
    }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    console.error('General error in populateFakeMusicians:', error);
    return { success: false, message: `A general error occurred: ${error.message}`, errors: [{ generalError: error.message, stack: error.stack }] };
  } finally {
    await prisma.$disconnect();
  }
}
