// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://prisly.d/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model Musician {
  id                  String                 @id @default(uuid())
  userId              String                 @unique // Added @unique back to userId
  fullName            String
  email               String                 @unique
  city                String? // Changed from location to city
  province            String? // Added province
  bio                 String?
  phoneNumber         String? // Added phoneNumber
  hourlyRate          Int?
  youtubeUrl          String?
  soundcloudUrl       String?
  instagramUrl        String?
  profileImageUrl     String?
  isPremium           Boolean                @default(false)
  artisticName        String? // Made optional
  experienceLevel     String?
  servicesOffered     String[]
  influences          String[]
  gearHighlights      String[]
  preferredVenueTypes String[]
  lookingFor          String[]
  websiteUrl          String?
  audioSamples        Json?
  videoSamples        Json?
  pressKitUrl         String?
  profileCompleteness Int                    @default(0)
  isFeatured          Boolean                @default(false)
  createdAt           DateTime               @default(now())
  favorites           Favorite[]
  socialMediaLinks    Json? // Added socialMediaLinks as Json type
  audioTracks         Json? // Added for storing audio track information

  // Many-to-many relationships through join tables
  genres              MusicianGenre[]
  instruments         MusicianInstrument[]
  skills              MusicianSkill[]
  availability        MusicianAvailability[]
  preferences         MusicianPreference[]

  // New fields for profile completeness tracking (removed @map for camelCase consistency)
  isPublic            Boolean                @default(true) // Changed to non-optional with default true
  acceptsCollaborations Boolean?
  acceptsGigs         Boolean?

  // Custom profile colors
  profileColorCover           String? // Fondo de la sección de portada (superior) y potencialmente iconos
  profileColorCardBackground  String? // Fondo de las tarjetas individuales
  profileColorText            String? // Color de la tipografía principal
  profileColorSectionBackground String? // Fondo de la sección de contenido (inferior, donde están las tarjetas)
  musicianOrBand      String? // To differentiate between solo musician or band
  isAutogenerated     Boolean                @default(false) // To indicate if the profile was autogenerated

  conversations    Conversation[] @relation("MusicianConversations")
  messages         Message[]      @relation("MusicianMessages")
}

model Genre {
  id        String          @id @default(uuid())
  name      String          @unique
  musicians MusicianGenre[]
}

model Instrument {
  id        String             @id @default(uuid())
  name      String             @unique
  musicians MusicianInstrument[]
}

model Skill {
  id        String          @id @default(uuid())
  name      String          @unique
  musicians MusicianSkill[]
}

model Availability {
  id        String               @id @default(uuid())
  name      String               @unique
  musicians MusicianAvailability[]
}

model Preference {
  id        String             @id @default(uuid())
  name      String             @unique
  musicians MusicianPreference[]
}

model MusicianGenre {
  musicianId String
  genreId    String
  musician   Musician @relation(fields: [musicianId], references: [id], onDelete: Cascade)
  genre      Genre    @relation(fields: [genreId], references: [id])

  @@id([musicianId, genreId])
}

model MusicianInstrument {
  musicianId String
  instrumentId String
  musician   Musician   @relation(fields: [musicianId], references: [id], onDelete: Cascade)
  instrument Instrument @relation(fields: [instrumentId], references: [id])

  @@id([musicianId, instrumentId])
}

model MusicianSkill {
  musicianId String
  skillId    String
  musician   Musician @relation(fields: [musicianId], references: [id], onDelete: Cascade)
  skill      Skill    @relation(fields: [skillId], references: [id])

  @@id([musicianId, skillId])
}

model MusicianAvailability {
  musicianId String
  availabilityId String
  musician   Musician     @relation(fields: [musicianId], references: [id], onDelete: Cascade)
  availability Availability @relation(fields: [availabilityId], references: [id])

  @@id([musicianId, availabilityId])
}

model MusicianPreference {
  musicianId String
  preferenceId String
  musician   Musician   @relation(fields: [musicianId], references: [id], onDelete: Cascade)
  preference Preference @relation(fields: [preferenceId], references: [id])

  @@id([musicianId, preferenceId])
}

model Contractor {
  id              String   @id @default(uuid())
  userId          String   @unique
  fullName        String
  email           String   @unique
  location        String?
  isPremium       Boolean  @default(false)
  createdAt       DateTime @default(now())
  favorites       Favorite[]
  profileImageUrl String?
  companyName     String?
  websiteUrl      String?
  bio             String?

  conversations Conversation[] @relation("ContractorConversations")
  messages      Message[]      @relation("ContractorMessages")
}

model Favorite {
  id            String     @id @default(uuid())
  contractorId  String
  musicianId    String
  createdAt     DateTime   @default(now())
  contractor    Contractor @relation(fields: [contractorId], references: [id])
  musician      Musician   @relation(fields: [musicianId], references: [id], onDelete: Cascade)
}

model Payment {
  id        String   @id @default(uuid())
  userId    String
  role      String
  amount    Int
  status    String
  createdAt DateTime @default(now())
}

model Admin {
  id        String   @id @default(uuid())
  userId    String   @unique // Links to the auth user ID
  email     String   @unique // Stores the admin's email for easier identification
  createdAt DateTime @default(now())
}

model Feedback {
  id        String   @id @default(uuid())
  userId    String?  // Optional: links to the auth user ID if submitted by a logged-in user
  userName  String?  // Optional: name of the person submitting feedback
  userEmail String?  // Optional: email of the person submitting feedback
  type      String   // E.g., "bug", "suggestion", "comment", "question"
  message   String   @db.Text // Using Text for potentially longer messages
  status    String   @default("new") // E.g., "new", "read", "archived", "review_later"
  pageUrl   String?  // Optional: URL of the page where feedback was submitted
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt // To track when the status was last changed
}

model Conversation {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  musicianParticipants Musician[]   @relation("MusicianConversations")
  contractorParticipants Contractor[] @relation("ContractorConversations")
  messages               Message[]

  @@index(createdAt)
}

model Message {
  id             String   @id @default(uuid())
  conversationId String
  content        String   @db.Text
  createdAt      DateTime @default(now())

  // Sender information
  senderMusicianId   String?
  senderContractorId String?

  conversation     Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  senderMusician   Musician?    @relation("MusicianMessages", fields: [senderMusicianId], references: [id], onDelete: SetNull)
  senderContractor Contractor?  @relation("ContractorMessages", fields: [senderContractorId], references: [id], onDelete: SetNull)

  readBy           Json? // Store who has read the message, e.g., { "userId1": true, "userId2": false }

  @@index([conversationId, createdAt])
}

model YoutubeChannelCache {
  id         String   @id @default(uuid())
  vanityName String   @unique
  channelId  String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}
